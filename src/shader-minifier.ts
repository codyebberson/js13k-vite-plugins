import { mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, extname, relative, resolve } from 'node:path';
import { glob } from 'glob';
import type { Options as ShaderMinifierWasmOptions } from 'shader-minifier-wasm';
import { minify } from 'shader-minifier-wasm';
import type { HmrContext, ModuleNode, Plugin, ResolvedConfig } from 'vite';
import { addDefaultValues } from './utils';

export interface ShaderMinifierOptions {
  /**
   * Path where the generated TypeScript file will be written (e.g., './src/shaders.ts')
   * User will import from this file: import { mainVert } from './src/shaders'
   */
  outputFile: string;

  /**
   * Directory to scan for shader files (default: './src/shaders')
   */
  shaderDir?: string;

  /**
   * File extensions to recognize as shaders (default: ['.vert', '.frag', '.glsl'])
   */
  extensions?: string[];

  /**
   * shader-minifier-wasm options
   * @see https://github.com/laurentlb/shader-minifier#usage
   */
  minifierOptions?: ShaderMinifierWasmOptions;

  /**
   * Show verbose output
   */
  verbose?: boolean;
}

export const defaultShaderMinifierOptions: ShaderMinifierOptions = {
  outputFile: './src/shaders.ts',
  shaderDir: './src/shaders',
  extensions: ['.vert', '.frag', '.glsl'],
  minifierOptions: {
    format: 'js',
    preserveExternals: false,
  },
  verbose: true,
};

/**
 * Generates the TypeScript module file with all shader exports
 */
async function generateShaderModule(options: ShaderMinifierOptions, config: ResolvedConfig): Promise<void> {
  const shaderDir = resolve(config.root, options.shaderDir || './src/shaders');
  const extensions = options.extensions || ['.vert', '.frag', '.glsl'];

  // Glob patterns should always use / as a path separator,
  // even on Windows systems, as \ is used to escape glob characters.
  const pattern = `${shaderDir.replaceAll('\\', '/')}/**/*{${extensions.join(',')}}`;

  const files = glob.sync(pattern, { nodir: true });
  if (files.length === 0) {
    console.warn(`No shader files found in ${options.shaderDir}`);
    return;
  }

  const minifySources: Record<string, string> = {};
  for (const file of files) {
    const keyName = relative(shaderDir, file).replaceAll('\\', '/').toUpperCase();
    minifySources[keyName] = readFileSync(file, 'utf-8');
  }

  const minified = await minify(minifySources, { format: 'js' });

  const fixed = minified.replaceAll(/^var var_/gm, 'export const ').replaceAll(/^var /gm, 'export const ');

  const prefix = `// This file is auto-generated by shader-minifier plugin. Do not edit directly.\n`;

  const code = prefix + fixed;

  // Write the generated module to disk
  const outputPath = resolve(config.root, options.outputFile);
  const outputDir = dirname(outputPath);

  // Ensure output directory exists
  try {
    mkdirSync(outputDir, { recursive: true });
  } catch (_err) {
    // Directory might already exist, ignore
  }

  writeFileSync(outputPath, code, 'utf-8');

  if (options.verbose) {
    console.log(`Generated shader module: ${options.outputFile}`);
  }
}

/**
 * Creates the shader minifier plugin for Vite.
 * Processes GLSL shader files (.vert, .frag, .glsl), minifies them, and writes them
 * to a generated TypeScript file with named exports.
 *
 * @param options - Configuration options for the shader minifier plugin
 * @returns A Vite plugin instance
 */
export function shaderMinifierPlugin(options?: ShaderMinifierOptions): Plugin {
  const opts = addDefaultValues(options, defaultShaderMinifierOptions);
  let config: ResolvedConfig;

  return {
    name: 'js13k:shader-minifier',
    // No apply: 'build' - runs in both dev and build

    configResolved(resolvedConfig: ResolvedConfig): void {
      config = resolvedConfig;
    },

    async buildStart(): Promise<void> {
      // Generate the shader module when build starts
      await generateShaderModule(opts, config);
    },

    async handleHotUpdate({ file, server }: HmrContext): Promise<undefined | Array<ModuleNode>> {
      // Watch for shader file changes and regenerate
      const ext = extname(file);
      const extensions = opts.extensions || ['.vert', '.frag', '.glsl'];
      if (extensions.includes(ext)) {
        // Regenerate the shader module
        await generateShaderModule(opts, config);

        // Invalidate the generated file to trigger HMR
        const outputPath = resolve(config.root, opts.outputFile);
        const modules = server.moduleGraph.getModulesByFile(outputPath);
        if (modules) {
          return [...modules];
        }
      }

      return undefined;
    },
  };
}
