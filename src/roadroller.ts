import CleanCSS from 'clean-css';
import htmlMinify, { Options as HtmlMinifyOptions } from 'html-minifier-terser';
import { Input, InputAction, InputType, Packer, PackerOptions } from 'roadroller';
import { NormalizedOutputOptions, OutputAsset, OutputBundle, OutputChunk } from 'rollup';
import type { Plugin } from 'vite';
import { addDefaultValues, escapeRegExp } from './utils';

export type RoadrollerOptions = PackerOptions;

export const defaultRoadrollerOptions: RoadrollerOptions = {};

export type { HtmlMinifyOptions };

export const defaultHtmlMinifyOptions: HtmlMinifyOptions = {
  includeAutoGeneratedTags: true,
  removeAttributeQuotes: true,
  removeComments: true,
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  sortClassName: true,
  useShortDoctype: true,
  collapseWhitespace: true,
  collapseInlineTagWhitespace: true,
  removeEmptyAttributes: true,
  removeOptionalTags: true,
  sortAttributes: true,
};

/**
 * Creates the Roadroller plugin that crunches the JS and CSS.
 *
 * Based on Rob Louie's recommendations:
 * See: https://github.com/codyebberson/js13k-starter-2022/pull/1
 *
 * @returns The roadroller plugin.
 */
export function roadrollerPlugin(roadrollerOptions?: RoadrollerOptions, htmlMinifyOptions?: HtmlMinifyOptions): Plugin {
  const fullRoadrollerOptions = addDefaultValues(roadrollerOptions, defaultRoadrollerOptions);
  const fullHtmlMinifyOptions = addDefaultValues(htmlMinifyOptions, defaultHtmlMinifyOptions);

  // Store assets captured from the bundle
  let cssAsset: OutputAsset | undefined;
  let jsChunk: OutputChunk | undefined;

  return {
    name: 'js13k:roadroller',
    apply: 'build',

    // Remove CSS and JS from bundle before writing to disk
    generateBundle(_options: NormalizedOutputOptions, bundle: OutputBundle): void {
      const cssKey = Object.keys(bundle).find((key) => key.endsWith('.css'));
      if (cssKey) {
        cssAsset = bundle[cssKey] as OutputAsset;
        delete bundle[cssKey];
      }

      const jsKey = Object.keys(bundle).find((key) => key.endsWith('.js'));
      if (jsKey) {
        jsChunk = bundle[jsKey] as OutputChunk;
        delete bundle[jsKey];
      }
    },

    transformIndexHtml: {
      order: 'post',
      handler: async (html: string): Promise<string> => {
        let result = html;

        if (cssAsset) {
          result = embedCss(result, cssAsset);
        }

        result = await htmlMinify.minify(result, fullHtmlMinifyOptions);

        if (jsChunk) {
          result = await embedJs(result, jsChunk, fullRoadrollerOptions);
        }

        return result;
      },
    },
  };
}

/**
 * Transforms the given JavaScript code into a packed version.
 * @param html The original HTML.
 * @param chunk The JavaScript output chunk from Rollup/Vite.
 * @returns The transformed HTML with the JavaScript embedded.
 */
async function embedJs(html: string, chunk: OutputChunk, options: RoadrollerOptions): Promise<string> {
  const scriptTagRemoved = html.replace(new RegExp(`<script[^>]*?${escapeRegExp(chunk.fileName)}[^>]*?></script>`), '');
  const htmlInJs = `document.write('${scriptTagRemoved}');${chunk.code.trim()}`;
  const inputs: Input[] = [
    {
      data: htmlInJs,
      type: 'js' as InputType,
      action: 'eval' as InputAction,
    },
  ];
  const packer = new Packer(inputs, options);
  await packer.optimize(2);
  const { firstLine, secondLine } = packer.makeDecoder();
  return `<script>\n${firstLine}\n${secondLine}\n</script>`;
}

/**
 * Embeds CSS into the HTML.
 * @param html The original HTML.
 * @param asset The CSS asset.
 * @returns The transformed HTML with the CSS embedded.
 */
function embedCss(html: string, asset: OutputAsset): string {
  const reCSS = new RegExp(`<link [^>]*?href="[./]*${escapeRegExp(asset.fileName)}"[^>]*?>`);
  const code = `<style>${new CleanCSS({ level: 2 }).minify(asset.source as string).styles}</style>`;
  return html.replace(reCSS, code);
}
